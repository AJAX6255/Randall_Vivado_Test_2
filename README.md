# Digital Clock Design Using Basys 3 Board

This repository contains the Verilog code and related files for designing a digital clock in a 24-hour format, implemented and demonstrated using the Basys 3 FPGA board.

## Features

- **Second, Minute, and Hour Counting:** The clock counts seconds, which cascade to minutes and hours.
- **12/24-Hour Format Toggle:** Option to toggle between 12-hour and 24-hour formats.
- **Reset and Set Time Functionality:** The clock can be reset to zero and set to any desired time in HHMMSS format.
- **Time Display:** The current time is displayed in HHMM or MMSS format on the Basys 3 board using four 7-segment displays.
- **Stopwatch:** A stopwatch feature is included for time tracking.
- **Simulation and Testing:** The design is tested and simulated using open-source tools like Icarus Verilog (iverilog) and GTKWave to verify the waveforms.
- **Bonus Features:** Additional features such as an alarm (indicated by a blinking LED) are also implemented.

## Tools Used

- **Vivado:** For synthesis and implementation of the design on the Basys 3 board.
- **Icarus Verilog:** For simulating the Verilog code.
- **GTKWave:** For viewing simulation waveforms.

## How to Use

1. Clone the repository:
   ```bash
   git clone https://github.com/AJAX6255/Randall_Vivado_Test_2
   ```
2. Open the project in Vivado.
3. Synthesize, implement, and generate the bitstream.
4. Program the Basys 3 board with the generated bitstream.
5. Use the onboard buttons to reset or set the clock time.
---------------------------------------------------------------------
## Project Files Explanation

This section describes each of the files and folders generated in the Vivado project for the **DigitalClock**. These files are essential for the synthesis, implementation, and management of the project in Vivado.

- **DigitalClock_vivado.cache/wt**  
  This folder contains Vivado's internal cache files, which store data that helps speed up loading and saves information about project state.

- **project.wpc**  
  This file contains Vivado workspace settings, such as project layout and tool configurations.

- **synthesis.wdf & synthesis_details.wdf**  
  These files store synthesis data and additional synthesis details generated by Vivado. They contain intermediate synthesis information, used during the process of converting the HDL code into a hardware description.

- **webtalk_pa.xml**  
  This XML file logs information for Vivado’s WebTalk feature, which collects tool usage data for support and improvement purposes.

- **DigitalClock_vivado.hw & hw_1**  
  The `DigitalClock_vivado.hw` file and `hw_1` directory store hardware-specific configuration data and resources used during the hardware programming phase, including data needed for debugging and implementation on physical hardware.

- **DigitalClock_new.lpr**  
  This is a Vivado-generated log file that contains data about the project's synthesis, implementation, and any logged activity.

- **DigitalClock_vivado.runs**  
  This folder contains run directories for synthesis (`synth_1`) and implementation (`impl_1`). Each subdirectory holds data and intermediate files generated during the synthesis and implementation processes.

- **.jobs**  
  The `.jobs` folder is a temporary directory that contains data about background processing jobs running in Vivado.

- **impl_1 & synth_1**  
  These directories contain synthesized and implemented design files respectively. `synth_1` holds data files related to the synthesis stage, while `impl_1` contains files for the implementation stage, which is where Vivado maps the design to actual hardware resources.

- **DigitalClock_vivado.srcs**  
  The `DigitalClock_vivado.srcs` folder contains all the source files and constraints associated with the project, including HDL source code, block diagrams, and imported files.

- **constrs_1/imports/basys3_constrain.xdc**  
  This is a constraints file in XDC format, specifying hardware constraints for the Basys 3 FPGA board, such as pin assignments, timing requirements, and other design rules.

- **sources_1/new**  
  This folder contains HDL source files and other new files that have been added to the project’s source group, categorized by Vivado for organization within the project structure.

- **utils_1/imports/synth_1**  
  This directory contains synthesis utility files imported into the project, which may include additional modules, libraries, or helper scripts.

- **.gitattributes**  
  The `.gitattributes` file is used to manage Git attributes and configure behaviors specific to file types within the repository. It can control handling of text encoding, line endings, and more for collaboration.

- **DigitalClock_vivado.xpr**  
  This is the main project file for Vivado, which stores the project configuration and tracks all associated files. Opening this file in Vivado will load the entire project structure.

----------------------------------------------------------------------------------------------------------------
# Using ChatGPT to Generate VHDL Code for Basys 3 Stopwatch Project

To use ChatGPT effectively for generating VHDL code for the Basys 3 stopwatch project, you can structure your prompts to ensure clarity and specificity, which helps the model produce more accurate code. Here’s a suggested approach for each module, along with prompt examples to guide the model:

## 1. General Prompt Tips
- Be explicit about the purpose of each module and specify inputs, outputs, and expected behavior.
- Include details about the Basys 3's hardware requirements, like clock frequency and button configuration, as it can affect timing and debouncing logic.

## 2. Module-Specific Prompts

### `seven_segment_display.v`
**Prompt Example**:
> "Generate VHDL code for a `seven_segment_display` module for the Basys 3 board. This module should take a 4-bit binary input and display it on a four-digit seven-segment display. Please include multiplexing to display four different digits sequentially, refreshing fast enough for a continuous display effect."

### `clock_divider.v`
**Prompt Example**:
> "Write VHDL code for a `clock_divider` module that takes the 100 MHz clock signal from the Basys 3 board and divides it down to a 1 Hz signal for timing purposes. This 1 Hz clock will be used by the stopwatch logic to update the time once per second."

### `buttonDebouncer.v`
**Prompt Example**:
> "Create a `buttonDebouncer` VHDL module to handle the Basys 3 start/stop and reset buttons. The module should debounce the inputs to provide stable signals, avoiding false triggers from mechanical noise in the buttons."

### `stopwatch.v`
**Prompt Example**:
> "Develop VHDL code for a `stopwatch` module that implements start/stop and reset functionality. The stopwatch should increment time in seconds using the 1 Hz clock from the `clock_divider` and reset to zero when the reset signal is active. Include `start_stop` and `reset` inputs."

### `top_level.v`
**Prompt Example**:
> "Write a `top_level` VHDL module that integrates the `seven_segment_display`, `clock_divider`, `buttonDebouncer`, and `stopwatch` modules to create a functioning stopwatch. This module should connect the debounced button signals, handle the divided clock signal, and display the stopwatch time on the Basys 3’s seven-segment display."

## 3. Simulation Testbench: `top_level_tb.v`
**Prompt Example**:
> "Generate a `top_level_tb` testbench for the `top_level` module in VHDL. This testbench should simulate the functionality of the stopwatch by providing stimulus for the start/stop and reset buttons and monitoring the seven-segment display outputs to verify correct time progression."

## 4. Testing and Iteration
After generating code, you may need to test it in Vivado and identify issues or optimizations. You can use ChatGPT to refine specific parts by describing the problems encountered.

For example:
> "The seven-segment display flickers when showing time. How can I adjust the `seven_segment_display` code to avoid flickering?"

## Additional Tip
Once you have a basic version, you can also use ChatGPT to ask for performance optimizations or alternative implementations, such as using finite state machines (FSMs) for timing control.
